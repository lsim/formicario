/* Generated by antcc - The AntC Compiler (http://antc.dotasterisk.net)*/
#include "Myre.h"
#define printf(...) 
enum { CLASS_Militant=0, CLASS_GpsAnt=16, CLASS_Forager=32, CLASS_Guard=48, CLASS_Scout=64, CLASS_Messenger=80, CLASS_Transporter=96, CLASS_General=112, CLASS_Recruiter=128};
enum { NONE, Init, CW, Guard, General, Create, Source, Search, Patrol, Return, Fetch, CCW, Recruit, Deploy};
#define FETCH(obj,member) (obj)->member
#define REDISPATCH(C,S) return Militant_REDISPATCH(field,mem,CLASS_##C,S)
#define CLASS(A) ((A)->class_state & 0xf0)
#define STATE(A) ((A)->class_state & 0x0f)
struct Militant {
  /* isa:  */
  /* methods: getState, setState, getClass, setClass, rnd, kill, has, has, food, base, rnd */
char STUFFING[4];
  u_char class_state;
};
struct GpsAnt {
  /* isa: Militant */
  /* methods: atHome, forceHome, setHome, atTarget, setTarget, gps, posOverflow, Deploy, moveTo, move, home, posOverflow, getState, setState, getClass, setClass, rnd, kill, has, food, base */
  char x;
  char y;
  char x1;
  char y1;
  u_char class_state;
};
struct Forager {
  /* isa: GpsAnt */
  /* methods: learn, teach, Search, CW, CCW, search, Return, Source, Init, atHome, forceHome, setHome, atTarget, setTarget, gps, posOverflow, Deploy, moveTo, move, home, getState, setState, getClass, setClass, rnd, kill, has, food, base */
  char x;
  char y;
  char x1;
  char y1;
  u_char class_state;
};
struct Guard {
  /* isa: GpsAnt */
  /* methods: Guard, Init, Guard, Init, atHome, forceHome, setHome, atTarget, setTarget, gps, posOverflow, Deploy, moveTo, move, home, getState, setState, getClass, setClass, rnd, kill, has, food, base */
  char x;
  char y;
  char x1;
  char y1;
  u_char class_state;
};
struct Scout {
  /* isa: Militant */
  /* methods: Patrol, Init, Create, getState, setState, getClass, setClass, rnd, kill, has, food, base */
  u_char quadrant;
  u_char radius;
  u_char leg;
  u_char pos;
  u_char class_state;
};
struct Messenger {
  /* isa: Militant */
  /* methods: Return, Init, getState, setState, getClass, setClass, rnd, kill, has, food, base */
  u_char octant_food;
  u_char radius;
  u_char pos0;
  u_char pos;
  u_char class_state;
};
struct Transporter {
  /* isa: GpsAnt */
  /* methods: Fetch, Return, atHome, forceHome, setHome, atTarget, setTarget, gps, posOverflow, Deploy, moveTo, move, home, getState, setState, getClass, setClass, rnd, kill, has, food, base */
  char x;
  char y;
  char x1;
  char y1;
  u_char class_state;
};
struct General {
  /* isa: Militant */
  /* methods: General, Init, getState, setState, getClass, setClass, rnd, kill, has, food, base */
  u_char quadrant;
  u_char radius;
  u_char cycles;
char STUFFING[1];
  u_char class_state;
};
struct Recruiter {
  /* isa: Militant */
  /* methods: Recruit, Init, getState, setState, getClass, setClass, rnd, kill, has, food, base */
  char x;
  char y;
  u_char food;
char STUFFING[1];
  u_char class_state;
};
#define POS char
#define MAX_POS 127
#define MAX_SUM 196
/*
  for(i=0;i<field->NumAnts;++i)
    printf("Ant[%d]: (%d,%d) (%d,%d) [%d %d]\n",i,mem[i].STUFFING[0],mem[i].STUFFING[1],mem[i].STUFFING[2],mem[i].STUFFING[3],mem[i].class,mem[i].state);
*/
#define spread 96
  enum { center=0, east=1, south=2, west=3, north=4 }; // Directions
  enum { ne=0, nw=1, sw=2, se=3 }; // Quadrants (first half of octants)
  enum { en=4, wn=5, ws=6, es=7 }; // Octants (second half)
  
  const u_char route[4][4] = {
    {north, east,  south, west},  // ne
    {west,  north, east,  south}, // nw
    {south, west,  north, east},  // sw
    {east,  south, west,  north}  // se
  };
  // route[q][l] == direction to move in quadrant q, on leg l.
  
  const u_char octants[4][4] = {
    {ne, ne, en, en}, // ne
    {wn, wn, nw, nw}, // nw
    {sw, sw, ws, ws}, // sw
    {es, es, se, se}  // se
  };
  // octants[q][l] = octant of quadrant q, leg l.
  
  const u_char returnRoute[8][2] = {
    {west, south}, // ne
    {south, east}, // nw
    {east, north}, // sw
    {north, west}, // se
    {west, south}, // en
    {south, east}, // wn
    {east, north}, // ws
    {north, west}  // es
  };
  // route[o][l] == direction to move in octant o, on leg l.
  
  //enum { ne=0x00, nw=0x40, se=0x80, sw=0xC0 }; // Quadrants
  //enum { en=0x20, wn=0x60, es=0xA0, ws=0xE0 }; // Octants

int Militant(struct SquareData*, struct Militant*);
int Militant_Transporter_Return (struct SquareData* field, struct Militant* mem);
int Militant_Guard_Init (struct SquareData* field, struct Militant* mem);
int Militant_GpsAnt_atHome (struct SquareData* field, struct Militant* mem);
u_char Militant_Militant_getClass (struct SquareData* field, struct Militant* mem);
int Militant_GpsAnt_moveTo (struct SquareData* field, struct Militant* mem, POS tx,  POS ty);
void Militant_GpsAnt_setHome (struct SquareData* field, struct Militant* mem, POS x0,  POS y0);
int Militant_Militant_has (struct SquareData* field, struct Militant* mem, u_char c,  u_char s);
int Militant_Forager_Source (struct SquareData* field, struct Militant* mem);
int Militant_Forager_Search (struct SquareData* field, struct Militant* mem);
int Militant_Forager_search (struct SquareData* field, struct Militant* mem, int cos,  int sin,  int skrue);
u_char Militant_Militant_base (struct SquareData* field, struct Militant* mem);
u_char Militant_Militant_getState (struct SquareData* field, struct Militant* mem);
int Militant_Recruiter_Init (struct SquareData* field, struct Militant* mem);
u_long Militant_Militant_rnd (struct SquareData* field, struct Militant* mem, u_long num);
int Militant_General_Init (struct SquareData* field, struct Militant* mem);
int Militant_Transporter_Fetch (struct SquareData* field, struct Militant* mem);
int Militant_Scout_Init (struct SquareData* field, struct Militant* mem);
int Militant_Forager_Return (struct SquareData* field, struct Militant* mem);
int Militant_Forager_CW (struct SquareData* field, struct Militant* mem);
int Militant_Guard_Guard (struct SquareData* field, struct Militant* mem);
u_char Militant_Militant_kill (struct SquareData* field, struct Militant* mem, u_char dir);
void Militant_Forager_teach (struct SquareData* field, struct Militant* mem);
int Militant_Forager_CCW (struct SquareData* field, struct Militant* mem);
int Militant_Scout_Create (struct SquareData* field, struct Militant* mem);
int Militant_GpsAnt_atTarget (struct SquareData* field, struct Militant* mem);
void Militant_Militant_setClass (struct SquareData* field, struct Militant* mem, u_char c);
int Militant_Scout_Patrol (struct SquareData* field, struct Militant* mem);
int Militant_Messenger_Init (struct SquareData* field, struct Militant* mem);
void Militant_Militant_setState (struct SquareData* field, struct Militant* mem, u_char s);
int Militant_GpsAnt_gps (struct SquareData* field, struct Militant* mem, u_char dir);
int Militant_Forager_Init (struct SquareData* field, struct Militant* mem);
int Militant_General_General (struct SquareData* field, struct Militant* mem);
void Militant_GpsAnt_posOverflow (struct SquareData* field, struct Militant* mem);
void Militant_GpsAnt_setTarget (struct SquareData* field, struct Militant* mem, POS tx,  POS ty);
int Militant_GpsAnt_home (struct SquareData* field, struct Militant* mem);
int Militant_Recruiter_Recruit (struct SquareData* field, struct Militant* mem);
u_char Militant_Militant_food (struct SquareData* field, struct Militant* mem);
int Militant_GpsAnt_move (struct SquareData* field, struct Militant* mem);
int Militant_GpsAnt_Deploy (struct SquareData* field, struct Militant* mem);
int Militant_Messenger_Return (struct SquareData* field, struct Militant* mem);
int Militant_Forager_learn (struct SquareData* field, struct Militant* mem);
void Militant_GpsAnt_forceHome (struct SquareData* field, struct Militant* mem, POS x0,  POS y0);
int Militant_REDISPATCH(struct SquareData* field, struct Militant* mem, u_char class, u_char state) {
  mem->class_state=class|state;
  return Militant(field, mem);
}
void Militant_SWAP(struct Militant* obj, struct Militant* mem)
{
  struct Militant tmp = *obj; *obj = *mem; *mem = tmp; 
}
int Militant_CW(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Forager: result = Militant_Forager_CW(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (CW) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_General(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_General: result = Militant_General_General(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (General) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
u_char Militant_base(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  u_char result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Militant: result = Militant_Militant_base(fields,mem); break;
  case CLASS_GpsAnt: result = Militant_Militant_base(fields,mem); break;
  case CLASS_Forager: result = Militant_Militant_base(fields,mem); break;
  case CLASS_Guard: result = Militant_Militant_base(fields,mem); break;
  case CLASS_Scout: result = Militant_Militant_base(fields,mem); break;
  case CLASS_Messenger: result = Militant_Militant_base(fields,mem); break;
  case CLASS_Transporter: result = Militant_Militant_base(fields,mem); break;
  case CLASS_General: result = Militant_Militant_base(fields,mem); break;
  case CLASS_Recruiter: result = Militant_Militant_base(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (base) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_Search(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Forager: result = Militant_Forager_Search(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Search) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_Source(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Forager: result = Militant_Forager_Source(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Source) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_search(struct SquareData* fields, struct Militant* mem, struct Militant* obj, int cos, int sin, int skrue) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Forager: result = Militant_Forager_search(fields,mem,cos,sin,skrue); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (search) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
void Militant_setClass(struct SquareData* fields, struct Militant* mem, struct Militant* obj, u_char c) {
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Militant: Militant_Militant_setClass(fields,mem,c); break;
  case CLASS_GpsAnt: Militant_Militant_setClass(fields,mem,c); break;
  case CLASS_Forager: Militant_Militant_setClass(fields,mem,c); break;
  case CLASS_Guard: Militant_Militant_setClass(fields,mem,c); break;
  case CLASS_Scout: Militant_Militant_setClass(fields,mem,c); break;
  case CLASS_Messenger: Militant_Militant_setClass(fields,mem,c); break;
  case CLASS_Transporter: Militant_Militant_setClass(fields,mem,c); break;
  case CLASS_General: Militant_Militant_setClass(fields,mem,c); break;
  case CLASS_Recruiter: Militant_Militant_setClass(fields,mem,c); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (setClass) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
}
void Militant_setHome(struct SquareData* fields, struct Militant* mem, struct Militant* obj, POS x0, POS y0) {
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: Militant_GpsAnt_setHome(fields,mem,x0,y0); break;
  case CLASS_Forager: Militant_GpsAnt_setHome(fields,mem,x0,y0); break;
  case CLASS_Guard: Militant_GpsAnt_setHome(fields,mem,x0,y0); break;
  case CLASS_Transporter: Militant_GpsAnt_setHome(fields,mem,x0,y0); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (setHome) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
}
void Militant_setState(struct SquareData* fields, struct Militant* mem, struct Militant* obj, u_char s) {
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Militant: Militant_Militant_setState(fields,mem,s); break;
  case CLASS_GpsAnt: Militant_Militant_setState(fields,mem,s); break;
  case CLASS_Forager: Militant_Militant_setState(fields,mem,s); break;
  case CLASS_Guard: Militant_Militant_setState(fields,mem,s); break;
  case CLASS_Scout: Militant_Militant_setState(fields,mem,s); break;
  case CLASS_Messenger: Militant_Militant_setState(fields,mem,s); break;
  case CLASS_Transporter: Militant_Militant_setState(fields,mem,s); break;
  case CLASS_General: Militant_Militant_setState(fields,mem,s); break;
  case CLASS_Recruiter: Militant_Militant_setState(fields,mem,s); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (setState) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
}
int Militant_Guard(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Guard: result = Militant_Guard_Guard(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Guard) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
void Militant_setTarget(struct SquareData* fields, struct Militant* mem, struct Militant* obj, POS tx, POS ty) {
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: Militant_GpsAnt_setTarget(fields,mem,tx,ty); break;
  case CLASS_Forager: Militant_GpsAnt_setTarget(fields,mem,tx,ty); break;
  case CLASS_Guard: Militant_GpsAnt_setTarget(fields,mem,tx,ty); break;
  case CLASS_Transporter: Militant_GpsAnt_setTarget(fields,mem,tx,ty); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (setTarget) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
}
int Militant_learn(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Forager: result = Militant_Forager_learn(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (learn) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_has(struct SquareData* fields, struct Militant* mem, struct Militant* obj, u_char c, u_char s) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Militant: result = Militant_Militant_has(fields,mem,c,s); break;
  case CLASS_GpsAnt: result = Militant_Militant_has(fields,mem,c,s); break;
  case CLASS_Forager: result = Militant_Militant_has(fields,mem,c,s); break;
  case CLASS_Guard: result = Militant_Militant_has(fields,mem,c,s); break;
  case CLASS_Scout: result = Militant_Militant_has(fields,mem,c,s); break;
  case CLASS_Messenger: result = Militant_Militant_has(fields,mem,c,s); break;
  case CLASS_Transporter: result = Militant_Militant_has(fields,mem,c,s); break;
  case CLASS_General: result = Militant_Militant_has(fields,mem,c,s); break;
  case CLASS_Recruiter: result = Militant_Militant_has(fields,mem,c,s); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (has) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
u_char Militant_kill(struct SquareData* fields, struct Militant* mem, struct Militant* obj, u_char dir) {
  u_char result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Militant: result = Militant_Militant_kill(fields,mem,dir); break;
  case CLASS_GpsAnt: result = Militant_Militant_kill(fields,mem,dir); break;
  case CLASS_Forager: result = Militant_Militant_kill(fields,mem,dir); break;
  case CLASS_Guard: result = Militant_Militant_kill(fields,mem,dir); break;
  case CLASS_Scout: result = Militant_Militant_kill(fields,mem,dir); break;
  case CLASS_Messenger: result = Militant_Militant_kill(fields,mem,dir); break;
  case CLASS_Transporter: result = Militant_Militant_kill(fields,mem,dir); break;
  case CLASS_General: result = Militant_Militant_kill(fields,mem,dir); break;
  case CLASS_Recruiter: result = Militant_Militant_kill(fields,mem,dir); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (kill) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_Return(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Forager: result = Militant_Forager_Return(fields,mem); break;
  case CLASS_Messenger: result = Militant_Messenger_Return(fields,mem); break;
  case CLASS_Transporter: result = Militant_Transporter_Return(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Return) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
void Militant_forceHome(struct SquareData* fields, struct Militant* mem, struct Militant* obj, POS x0, POS y0) {
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: Militant_GpsAnt_forceHome(fields,mem,x0,y0); break;
  case CLASS_Forager: Militant_GpsAnt_forceHome(fields,mem,x0,y0); break;
  case CLASS_Guard: Militant_GpsAnt_forceHome(fields,mem,x0,y0); break;
  case CLASS_Transporter: Militant_GpsAnt_forceHome(fields,mem,x0,y0); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (forceHome) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
}
int Militant_Deploy(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: result = Militant_GpsAnt_Deploy(fields,mem); break;
  case CLASS_Forager: result = Militant_GpsAnt_Deploy(fields,mem); break;
  case CLASS_Guard: result = Militant_GpsAnt_Deploy(fields,mem); break;
  case CLASS_Transporter: result = Militant_GpsAnt_Deploy(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Deploy) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_Init(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Forager: result = Militant_Forager_Init(fields,mem); break;
  case CLASS_Guard: result = Militant_Guard_Init(fields,mem); break;
  case CLASS_Scout: result = Militant_Scout_Init(fields,mem); break;
  case CLASS_Messenger: result = Militant_Messenger_Init(fields,mem); break;
  case CLASS_General: result = Militant_General_Init(fields,mem); break;
  case CLASS_Recruiter: result = Militant_Recruiter_Init(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Init) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
u_long Militant_rnd(struct SquareData* fields, struct Militant* mem, struct Militant* obj, u_long num) {
  u_long result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Militant: result = Militant_Militant_rnd(fields,mem,num); break;
  case CLASS_GpsAnt: result = Militant_Militant_rnd(fields,mem,num); break;
  case CLASS_Forager: result = Militant_Militant_rnd(fields,mem,num); break;
  case CLASS_Guard: result = Militant_Militant_rnd(fields,mem,num); break;
  case CLASS_Scout: result = Militant_Militant_rnd(fields,mem,num); break;
  case CLASS_Messenger: result = Militant_Militant_rnd(fields,mem,num); break;
  case CLASS_Transporter: result = Militant_Militant_rnd(fields,mem,num); break;
  case CLASS_General: result = Militant_Militant_rnd(fields,mem,num); break;
  case CLASS_Recruiter: result = Militant_Militant_rnd(fields,mem,num); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (rnd) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_Create(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Scout: result = Militant_Scout_Create(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Create) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_atTarget(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: result = Militant_GpsAnt_atTarget(fields,mem); break;
  case CLASS_Forager: result = Militant_GpsAnt_atTarget(fields,mem); break;
  case CLASS_Guard: result = Militant_GpsAnt_atTarget(fields,mem); break;
  case CLASS_Transporter: result = Militant_GpsAnt_atTarget(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (atTarget) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
u_char Militant_getClass(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  u_char result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Militant: result = Militant_Militant_getClass(fields,mem); break;
  case CLASS_GpsAnt: result = Militant_Militant_getClass(fields,mem); break;
  case CLASS_Forager: result = Militant_Militant_getClass(fields,mem); break;
  case CLASS_Guard: result = Militant_Militant_getClass(fields,mem); break;
  case CLASS_Scout: result = Militant_Militant_getClass(fields,mem); break;
  case CLASS_Messenger: result = Militant_Militant_getClass(fields,mem); break;
  case CLASS_Transporter: result = Militant_Militant_getClass(fields,mem); break;
  case CLASS_General: result = Militant_Militant_getClass(fields,mem); break;
  case CLASS_Recruiter: result = Militant_Militant_getClass(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (getClass) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_atHome(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: result = Militant_GpsAnt_atHome(fields,mem); break;
  case CLASS_Forager: result = Militant_GpsAnt_atHome(fields,mem); break;
  case CLASS_Guard: result = Militant_GpsAnt_atHome(fields,mem); break;
  case CLASS_Transporter: result = Militant_GpsAnt_atHome(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (atHome) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_Patrol(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Scout: result = Militant_Scout_Patrol(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Patrol) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_moveTo(struct SquareData* fields, struct Militant* mem, struct Militant* obj, POS tx, POS ty) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: result = Militant_GpsAnt_moveTo(fields,mem,tx,ty); break;
  case CLASS_Forager: result = Militant_GpsAnt_moveTo(fields,mem,tx,ty); break;
  case CLASS_Guard: result = Militant_GpsAnt_moveTo(fields,mem,tx,ty); break;
  case CLASS_Transporter: result = Militant_GpsAnt_moveTo(fields,mem,tx,ty); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (moveTo) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_Fetch(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Transporter: result = Militant_Transporter_Fetch(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Fetch) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
u_char Militant_getState(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  u_char result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Militant: result = Militant_Militant_getState(fields,mem); break;
  case CLASS_GpsAnt: result = Militant_Militant_getState(fields,mem); break;
  case CLASS_Forager: result = Militant_Militant_getState(fields,mem); break;
  case CLASS_Guard: result = Militant_Militant_getState(fields,mem); break;
  case CLASS_Scout: result = Militant_Militant_getState(fields,mem); break;
  case CLASS_Messenger: result = Militant_Militant_getState(fields,mem); break;
  case CLASS_Transporter: result = Militant_Militant_getState(fields,mem); break;
  case CLASS_General: result = Militant_Militant_getState(fields,mem); break;
  case CLASS_Recruiter: result = Militant_Militant_getState(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (getState) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_CCW(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Forager: result = Militant_Forager_CCW(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (CCW) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_Recruit(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Recruiter: result = Militant_Recruiter_Recruit(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (Recruit) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
void Militant_posOverflow(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: Militant_GpsAnt_posOverflow(fields,mem); break;
  case CLASS_Forager: Militant_GpsAnt_posOverflow(fields,mem); break;
  case CLASS_Guard: Militant_GpsAnt_posOverflow(fields,mem); break;
  case CLASS_Transporter: Militant_GpsAnt_posOverflow(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (posOverflow) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
}
int Militant_gps(struct SquareData* fields, struct Militant* mem, struct Militant* obj, u_char dir) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: result = Militant_GpsAnt_gps(fields,mem,dir); break;
  case CLASS_Forager: result = Militant_GpsAnt_gps(fields,mem,dir); break;
  case CLASS_Guard: result = Militant_GpsAnt_gps(fields,mem,dir); break;
  case CLASS_Transporter: result = Militant_GpsAnt_gps(fields,mem,dir); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (gps) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
u_char Militant_food(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  u_char result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Militant: result = Militant_Militant_food(fields,mem); break;
  case CLASS_GpsAnt: result = Militant_Militant_food(fields,mem); break;
  case CLASS_Forager: result = Militant_Militant_food(fields,mem); break;
  case CLASS_Guard: result = Militant_Militant_food(fields,mem); break;
  case CLASS_Scout: result = Militant_Militant_food(fields,mem); break;
  case CLASS_Messenger: result = Militant_Militant_food(fields,mem); break;
  case CLASS_Transporter: result = Militant_Militant_food(fields,mem); break;
  case CLASS_General: result = Militant_Militant_food(fields,mem); break;
  case CLASS_Recruiter: result = Militant_Militant_food(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (food) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
void Militant_teach(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_Forager: Militant_Forager_teach(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (teach) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
}
int Militant_home(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: result = Militant_GpsAnt_home(fields,mem); break;
  case CLASS_Forager: result = Militant_GpsAnt_home(fields,mem); break;
  case CLASS_Guard: result = Militant_GpsAnt_home(fields,mem); break;
  case CLASS_Transporter: result = Militant_GpsAnt_home(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (home) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_move(struct SquareData* fields, struct Militant* mem, struct Militant* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Militant_SWAP(obj,mem);
  switch(CLASS(mem)) {
  case CLASS_GpsAnt: result = Militant_GpsAnt_move(fields,mem); break;
  case CLASS_Forager: result = Militant_GpsAnt_move(fields,mem); break;
  case CLASS_Guard: result = Militant_GpsAnt_move(fields,mem); break;
  case CLASS_Transporter: result = Militant_GpsAnt_move(fields,mem); break;
  default: printf("class=%d\n",CLASS(mem)); assert(!"no such method (move) for ant ");
  }
  if (!onSelf) Militant_SWAP(obj,mem);
  return result;
}
int Militant_Transporter_Return (struct SquareData* field, struct Militant* mem)
{
  struct Transporter* ant = (struct Transporter*) mem;

  // at home?
  if (Militant_GpsAnt_atHome(field,mem)) {
    if (field->Base) REDISPATCH(Scout,Init);
    if (Militant_Militant_kill(field,mem, 0)) REDISPATCH(Guard,Init);
    if (field->NumAnts > (NewBaseAnts+5) && field->NumFood < NewBaseFood) REDISPATCH(Scout,Init);
    //printf ("food = %d; ants = %d;\n",field->NumFood, field->NumAnts);
    return 16;
  }
  
  // move along...
  return 8 + Militant_GpsAnt_home(field,mem);
}
int Militant_Guard_Init (struct SquareData* field, struct Militant* mem)
{
  struct Guard* ant = (struct Guard*) mem;

  REDISPATCH(Guard,Guard);
}
int Militant_GpsAnt_atHome (struct SquareData* field, struct Militant* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  return ant->x==0 && ant->y==0;
}
u_char Militant_Militant_getClass (struct SquareData* field, struct Militant* mem)
{
  struct Militant* ant = (struct Militant*) mem;

  return ant->class_state & 0xf0;
}
int Militant_GpsAnt_moveTo (struct SquareData* field, struct Militant* mem, POS tx,  POS ty)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  enum {center=0, east=1, south=2, west=3, north=4};
  POS dx = tx-ant->x;
  POS dy = ty-ant->y;
  u_char dir = 0;
  int kill = Militant_Militant_kill(field,mem, 0);
  if (kill) REDISPATCH(Guard,Init);
  
  if (dx && dy) Militant_Militant_rnd(field,mem, abs(dx)+abs(dy)) >= abs(dx) ? (dx=0) : (dy=0);
  if (dx && !dy) dir = dx<0 ? west : east;
  if (dy && !dx) dir = dy<0 ? south : north;
  return Militant_GpsAnt_gps(field,mem, dir);
}
void Militant_GpsAnt_setHome (struct SquareData* field, struct Militant* mem, POS x0,  POS y0)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  if(abs(x0)+abs(y0) < abs(ant->x)+abs(ant->y)) Militant_GpsAnt_forceHome(field,mem, x0,y0);
}
int Militant_Militant_has (struct SquareData* field, struct Militant* mem, u_char c,  u_char s)
{
  struct Militant* ant = (struct Militant*) mem;

  int i;
  for (i=1; i<field->NumAnts; ++i)
    if (Militant_getClass(field,mem,(struct Militant*)(&(ant[i]))) == c && Militant_getState(field,mem,(struct Militant*)(&(ant[i]))) == s) return i;
  return 0;
}
int Militant_Forager_Source (struct SquareData* field, struct Militant* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  int i;
  
  if ( (abs(ant->x) + abs(ant->y)) > 1) {
    // food in neighboring field?
    for (i=1; i<5; ++i) {
      if (field[i].NumFood > field[i].NumAnts) {
	Militant_Militant_setState(field,mem, Search);
	return Militant_GpsAnt_gps(field,mem, Militant_Militant_kill(field,mem, i));
      }
    }
  }
  
  if (Militant_GpsAnt_atTarget(field,mem)){
    // source reached. if there's food left, bring it home; otherwise init ant->random search
    if (field[0].NumFood && !Militant_GpsAnt_atHome(field,mem)) REDISPATCH(Forager,Return);
    else REDISPATCH(Forager,Init);
  }
  
  // move on.
  Militant_Forager_teach(field,mem);
  return Militant_GpsAnt_move(field,mem);
}
int Militant_Forager_Search (struct SquareData* field, struct Militant* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  if (!Militant_Militant_rnd(field,mem, 3)) REDISPATCH(Forager,CW);
  else REDISPATCH(Forager,CCW);
}
int Militant_Forager_search (struct SquareData* field, struct Militant* mem, int cos,  int sin,  int skrue)
{
  struct Forager* ant = (struct Forager*) mem;

  int i=0;
  int knowledge = Militant_Forager_learn(field,mem);
  
  if (abs(ant->x)>1 || abs(ant->y)>1) {
    // food here?
    if (field->NumFood) {
      // remember where the food is
      ant->x1 = ant->x;
      ant->y1 = ant->y;
      // and go home
      REDISPATCH(Forager,Return);
    }
    
    // food in neighboring field?
    for (i=1; i<5; ++i) {
      if (field[i].NumFood > field[i].NumAnts) {
	return Militant_GpsAnt_gps(field,mem, Militant_Militant_kill(field,mem, i));
      }
    }
  }
  
  // if target reached, go somewhere else
  if (Militant_GpsAnt_atTarget(field,mem)) { 
    Militant_GpsAnt_setTarget(field,mem,  ((ant->x1*cos-ant->y1*sin)/skrue)+Militant_Militant_rnd(field,mem, 15)-7, ((ant->y1*cos+ant->x1*sin)/skrue)+Militant_Militant_rnd(field,mem, 15)-7 );
    //REDISPATCH(Forager,Init);
    //printf("target reached\n");
    //ant->x1 += Militant_Militant_rnd(field,mem, 32) - 16;
    //ant->y1 += Militant_Militant_rnd(field,mem, 32) - 16;
  }
  else {
    if(knowledge) REDISPATCH(Forager,Source);
  }
  return Militant_GpsAnt_move(field,mem);
}
u_char Militant_Militant_base (struct SquareData* field, struct Militant* mem)
{

  int i;
  for (i=1; i<5; ++i) 
    if (field[i].Base) return i;
  return 0;
}
u_char Militant_Militant_getState (struct SquareData* field, struct Militant* mem)
{
  struct Militant* ant = (struct Militant*) mem;

  return ant->class_state & 0x0f;
}
int Militant_Recruiter_Init (struct SquareData* field, struct Militant* mem)
{
  struct Recruiter* ant = (struct Recruiter*) mem;

  int iy=0, ix=0;
  struct Messenger msg = *((struct Messenger*) ant);
  
  ant->food = (msg.octant_food & (0xFF^0x07)) >> 4;
  
  switch (msg.octant_food & 0x07) {
  case en:
    iy = (int)msg.radius - (int)msg.pos0; break;
  case ne:
    iy = (int)msg.radius; break;
  case nw:
    iy = (int)msg.radius; break;
  case wn:
    iy = (int)msg.pos0; break;
  case ws:
    iy = (int) msg.pos0 - msg.radius; break;
  case sw:
    iy = -(int)msg.radius; break;
  case se:
    iy = -(int)msg.radius; break;
  case es:
    iy = -(int)msg.pos0; break;
  }
  
  ant->y = (char)iy;
  
  switch (msg.octant_food & 0x07) {
  case en:
    ix = (int)msg.radius; break;
  case ne:
    ix = (int)msg.pos0; break;
  case nw:
    ix = (int)msg.pos0 - (int)msg.radius; break;
  case wn:
    ix = -(int)msg.radius; break;
  case ws:
    ix = -(int)msg.radius; break;
  case sw:
    ix = -(int)msg.pos0; break;
  case se:
    ix = (int)msg.radius - (int)msg.pos0; break;
  case es:
    ix = (int)msg.radius; break;
  }
  
  ant->x = (char) ix;
  
  //printf("recruiter::init (oct=%u,rad=%u,pos=%u) => (%d,%d) i(%d,%d)\n",msg.octant_food&0x07,msg.radius,msg.pos0,(int)ant->x,(int)ant->y,ix,iy);
  
  Militant_Militant_setState(field,mem, Recruit);
  Militant_Militant_setClass(field,mem, CLASS_Recruiter);
  return 8 + Militant_Militant_base(field,mem);
}
u_long Militant_Militant_rnd (struct SquareData* field, struct Militant* mem, u_long num)
{
  struct Militant* ant = (struct Militant*) mem;

  u_long n = 0, i = 0;
  n += 
    ant->STUFFING[0]+(ant->STUFFING[1]<<8)+
    ant->STUFFING[2]+(ant->STUFFING[3]<<8);
  for (i=1; i<5; ++i)
    n += field[i].NumFood+field[i].NumAnts;

//  n += *((u_long*)(&ant[field->NumAnts]));
  return n%num;
}
int Militant_General_Init (struct SquareData* field, struct Militant* mem)
{
  struct General* ant = (struct General*) mem;

  ant->quadrant = 0;
  ant->radius = 3;
  ant->cycles = 0;
  REDISPATCH(General,General);
}
int Militant_Transporter_Fetch (struct SquareData* field, struct Militant* mem)
{
  struct Transporter* ant = (struct Transporter*) mem;

  int i;
  /*
  struct General* g;
  // should we attempt to build a base?
  if (field->Base) {
    i = Militant_Militant_has(field,mem, CLASS_General, General);
    if (i) {
      g = (struct General*) &ant[i];
      if (g->cycles > 1) {
	i = (g->cycles/6) % 4;
	printf ("rehoming %d %d to %d\n",ant->x1,ant->y1, i);
	if (ant->x1 > 0 && ant->y1 > 0 && i==0) Militant_GpsAnt_forceHome(field,mem, -spread,-spread);
	else if (ant->x1 < 0 && ant->y1 > 0 && i==1) Militant_GpsAnt_forceHome(field,mem, spread,-spread);
	else if (ant->x1 > 0 && ant->y1 < 0 && i==2) Militant_GpsAnt_forceHome(field,mem, -spread,spread);
	else if (ant->x1 < 0 && ant->y1 < 0 && i==3) Militant_GpsAnt_forceHome(field,mem, spread,spread);
      }
    }
  }
  */
  
  // have we arrived near food source?
  if (Militant_GpsAnt_atTarget(field,mem)) {
    i = Militant_Militant_food(field,mem);
    Militant_Militant_setState(field,mem, Return);
    return Militant_GpsAnt_gps(field,mem, i);
  }
  
  // move along...
  return Militant_GpsAnt_move(field,mem);
}
int Militant_Scout_Init (struct SquareData* field, struct Militant* mem)
{
  struct Scout* ant = (struct Scout*) mem;

  u_long i, d;
  u_long minDist=0xffff, minI = 0;
  struct Recruiter* r;
  struct Forager* f;
  struct General* g = 0;
  
  // is there a recruiter in need of Transporters?
  for (i=0; i<field->NumAnts; ++i) {
    if ( Militant_getClass(field,mem,(struct Militant*)(&(ant[i])))==CLASS_Recruiter) {
      r = (struct Recruiter*) &ant[i];
      d = abs(r->x) + abs(r->y);
      if (d < minDist) {
	minI = i;
	minDist = d;
      }
    }
  }
  
  if (minI != 0) {
    r = (struct Recruiter*) &ant[minI];
    f = (struct Forager*) ant;
    if (r->food) {
      --r->food;
      f->x1 = r->x;
      f->y1 = r->y;
      f->x = 0;
      f->y = 0;
      //printf ("fetching %d @ (%d,%d) %d of %d\n",r->food,r->x,r->y,minI,field->NumAnts);
      REDISPATCH(Forager,Source);
    }
  }
  
  // is there need of a general?
  i = Militant_Militant_has(field,mem, CLASS_General, General);
  if (!i) REDISPATCH(General,Init);
  
  // take orders from General
  g = (struct General*) &ant[i];
  if (g->cycles > 5) {
    f = (struct Forager*) ant;
    f->x = 0;
    f->y = 0;
    f->x1 = 0;
    f->y1 = 0;
    REDISPATCH(Forager,Init);
  }
  
  
  ant->quadrant = g->quadrant;
  ant->radius = g->radius;
  ant->leg = 0;
  ant->pos = 0;
  
  // update General
  ++g->quadrant;
  if (g->quadrant==4) {
    g->quadrant = 0;
    g->radius += 3;
    if (g->radius > 127) {
      ++g->cycles;
      g->radius = 3;
    }
  }
  
  REDISPATCH(Scout,Patrol);
}
int Militant_Forager_Return (struct SquareData* field, struct Militant* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  
  if (Militant_GpsAnt_atHome(field,mem)) {
    // build a new base if possible
    if (Militant_Militant_kill(field,mem, 0)) REDISPATCH(Guard,Guard);
    if (field->NumAnts==1) return 0;
    if (field->NumFood >= NewBaseFood) return 16;
  }
  else {
    // any food to move? Then move it towards the base
    if (field->NumFood) {
      Militant_Forager_teach(field,mem);
      return 8 + Militant_GpsAnt_moveTo(field,mem, 0,0);
    }
  }
  
  // we've delivered the food at the base or lost the food. return to food source.
  Militant_Forager_teach(field,mem);
  REDISPATCH(Forager,Source);
}
int Militant_Forager_CW (struct SquareData* field, struct Militant* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  return Militant_Forager_search(field,mem, 222, -128, 222);
}
int Militant_Guard_Guard (struct SquareData* field, struct Militant* mem)
{
  struct Guard* ant = (struct Guard*) mem;

  return Militant_Militant_kill(field,mem, 0);
}
u_char Militant_Militant_kill (struct SquareData* field, struct Militant* mem, u_char dir)
{

  int i=0;
  for (i=1; i<5; ++i)
    if (field[i].Team) return i;
  return dir;
}
void Militant_Forager_teach (struct SquareData* field, struct Militant* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  int i;
  if(field[0].NumAnts==1) return;
  for(i=1; i<field[0].NumAnts; ++i) {
    //printf("teaching ant %d @ %d,%d", i,ant->x,ant->y);
    if (Militant_getClass(field,mem,(struct Militant*)(&(ant[i]))) == Militant_Militant_getClass(field,mem) && Militant_getState(field,mem,(struct Militant*)(&(ant[i]))) != Deploy) { // && ant[i].x==ant->x && ant[i].y==ant->y)
      Militant_GpsAnt_setHome(field,mem, ant[i].x, ant[i].y);
      Militant_setHome(field,mem,(struct Militant*)(&(ant[i])), ant->x,ant->y);
      if (Militant_getState(field,mem,(struct Militant*)(&(ant[i]))) == Search || Militant_getState(field,mem,(struct Militant*)(&(ant[i]))) == Init) {
	ant[i].x1 = ant->x1;
	ant[i].y1 = ant->y1;
	Militant_setState(field,mem,(struct Militant*)(&(ant[i])), Source);
	//printf(" about food @ %d,%d\n",xm,ym);
      }
      //printf("\n");
    }
  }
}
int Militant_Forager_CCW (struct SquareData* field, struct Militant* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  return Militant_Forager_search(field,mem, 222, 128, 222);
}
int Militant_Scout_Create (struct SquareData* field, struct Militant* mem)
{
  struct Scout* ant = (struct Scout*) mem;

  REDISPATCH(Scout,Init);
}
int Militant_GpsAnt_atTarget (struct SquareData* field, struct Militant* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  return ant->x==ant->x1 && ant->y==ant->y1;
}
void Militant_Militant_setClass (struct SquareData* field, struct Militant* mem, u_char c)
{
  struct Militant* ant = (struct Militant*) mem;

  ant->class_state = c | (ant->class_state & 0x0f);
}
int Militant_Scout_Patrol (struct SquareData* field, struct Militant* mem)
{
  struct Scout* ant = (struct Scout*) mem;

  // do we see the enemy?
  if (Militant_Militant_kill(field,mem, 0)) REDISPATCH(Guard,Init);
  
  // are we home?
  if (ant->leg>=4) REDISPATCH(Scout,Init);
  
  // have we found food?
  if (ant->leg!=0 && ant->leg!=3 && Militant_Militant_food(field,mem)!=0) REDISPATCH(Messenger,Init);
  
  // are we at end of ant->leg?
  if (ant->pos==ant->radius) {
    ++ant->leg;
    ant->pos = 0;
    REDISPATCH(Scout,Patrol);
  }
  
  // move along...
  ++ant->pos;
  return route[ant->quadrant][ant->leg];
}
int Militant_Messenger_Init (struct SquareData* field, struct Militant* mem)
{
  struct Messenger* ant = (struct Messenger*) mem;

  struct Scout scout = *((struct Scout*) ant);
  int f = Militant_Militant_food(field,mem);
  u_char numFood = field[f].NumFood;
  if (numFood > 63) numFood = 63;
  numFood <<= 3;
  
  ant->octant_food = octants[scout.quadrant][scout.leg] | numFood;
  ant->radius = scout.radius;
  ant->pos0 = scout.pos;
  if (scout.leg==1) {
    ant->pos = scout.pos;
  }
  else {
    ant->pos = scout.radius;
  }
  
  Militant_Militant_setState(field,mem, Return);
  return f;
}
void Militant_Militant_setState (struct SquareData* field, struct Militant* mem, u_char s)
{
  struct Militant* ant = (struct Militant*) mem;

  ant->class_state = (ant->class_state & 0xf0) | s;
}
int Militant_GpsAnt_gps (struct SquareData* field, struct Militant* mem, u_char dir)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;
 
  POS DX[5] = {0, 1,  0, -1,  0};
  POS DY[5] = {0, 0, -1,  0,  1};
  
  if (field[dir].NumAnts == MaxSquareAnts && !field[dir].Team) return 0;
  
  ant->x+=DX[dir];
  ant->y+=DY[dir];
  //if(abs(ant->x)==MAX_POS || abs(ant->y)==MAX_POS) Militant_GpsAnt_posOverflow(field,mem);
  if(abs(ant->x)+abs(ant->y)==MAX_SUM || abs(ant->x)==MAX_POS || abs(ant->y)==MAX_POS) {
    Militant_GpsAnt_posOverflow(field,mem);
  }
  return dir;
}
int Militant_Forager_Init (struct SquareData* field, struct Militant* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  short dx,dy;
  // become queen?
  //if (!Militant_Militant_has(field,mem, CLASS_Queen) && field->Base) REDISPATCH(Queen,Init);
  
  ant->x1+=0;
  ant->y1+=0;
  
  dx = Militant_Militant_rnd(field,mem, 32);
  dy = Militant_Militant_rnd(field,mem, 32)-dx;
  if(Militant_Militant_rnd(field,mem, 2)) dx = -dx;
  if(Militant_Militant_rnd(field,mem, 2)) dy = -dy;
  
  ant->x1 += dx;// - ant->x/4;
  ant->y1 += dy;// - ant->y/4;

  REDISPATCH(Forager,Search);
}
int Militant_General_General (struct SquareData* field, struct Militant* mem)
{
  struct General* ant = (struct General*) mem;

  //if (ant->radius > 3 && 0==Militant_Militant_has(field,mem, CLASS_Recruiter,Recruit)) --ant->radius;
  return 0;
}
void Militant_GpsAnt_posOverflow (struct SquareData* field, struct Militant* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  if (ant->x==MAX_POS) {
    Militant_GpsAnt_setHome(field,mem, 32,ant->y);
  }
  else if (ant->x==-MAX_POS) {
    Militant_GpsAnt_setHome(field,mem, -32,ant->y);
  }
  else if (ant->y==MAX_POS) {
    Militant_GpsAnt_setHome(field,mem, ant->x,32);
  }
  else if (ant->y==-MAX_POS) {
    Militant_GpsAnt_setHome(field,mem, ant->x,-32);
  }
}
void Militant_GpsAnt_setTarget (struct SquareData* field, struct Militant* mem, POS tx,  POS ty)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  ant->x1 = tx; 
  ant->y1 = ty;
}
int Militant_GpsAnt_home (struct SquareData* field, struct Militant* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  return Militant_GpsAnt_moveTo(field,mem, 0,0);
}
int Militant_Recruiter_Recruit (struct SquareData* field, struct Militant* mem)
{
  struct Recruiter* ant = (struct Recruiter*) mem;

  int i;
  
  // source empty ?
  if (ant->food==0) REDISPATCH(Scout,Init);
  
  // source already known?
  for (i=1; i<field->NumAnts; ++i) {
    if (Militant_getClass(field,mem,(struct Militant*)(&(ant[i])))==CLASS_Recruiter && 
	ant[i].x==ant->x && ant[i].y==ant->y)// && ant[i].food < ant->food)
      REDISPATCH(Scout,Init);
  }
  
  return 0;
}
u_char Militant_Militant_food (struct SquareData* field, struct Militant* mem)
{

  int i;
  for (i=1; i<5; ++i) 
    if (field[i].NumAnts < field[i].NumFood) return i;
  return 0;
}
int Militant_GpsAnt_move (struct SquareData* field, struct Militant* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  return Militant_GpsAnt_moveTo(field,mem, ant->x1,ant->y1);
}
int Militant_GpsAnt_Deploy (struct SquareData* field, struct Militant* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  if(Militant_GpsAnt_atTarget(field,mem)) Militant_Militant_setState(field,mem, Init);
  return Militant_GpsAnt_move(field,mem);
}
int Militant_Messenger_Return (struct SquareData* field, struct Militant* mem)
{
  struct Messenger* ant = (struct Messenger*) mem;

  u_char base = Militant_Militant_base(field,mem);
  
  // are we home?
  if (base) {
    REDISPATCH(Recruiter,Init);
  }
  
  // move along...
  if (ant->pos!=0) {
    --ant->pos;
    return 8 + returnRoute[ant->octant_food & 0x07][0];
  }
  else {
    return 8 + returnRoute[ant->octant_food & 0x07][1];
  }
}
int Militant_Forager_learn (struct SquareData* field, struct Militant* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  int i = 0;
  if(field[0].NumAnts==1) return 0;
  //printf("learning from %d ants %d @ %d,%d\n", field->NumAnts-1,i,ant->x,ant->y);
  for(i=1; i<field[0].NumAnts; ++i) {
    if (Militant_getClass(field,mem,(struct Militant*)(&(ant[i]))) == Militant_Militant_getClass(field,mem) && Militant_getState(field,mem,(struct Militant*)(&(ant[i]))) != Deploy) {
      Militant_GpsAnt_setHome(field,mem, ant[i].x, ant[i].y);
      Militant_setHome(field,mem,(struct Militant*)(&(ant[i])), ant->x,ant->y);
      if (Militant_getState(field,mem,(struct Militant*)(&(ant[i]))) == Return || Militant_getState(field,mem,(struct Militant*)(&(ant[i]))) == Source) {
	ant->x1 = ant[i].x1;
	ant->y1 = ant[i].y1;
	if (Militant_GpsAnt_atTarget(field,mem)) return 0;
	//printf(" learned about food @ %d,%d\n",ant->x1,ant->y1);
	return (ant->x1!=0 && ant->y1!=0);
      }
      //printf("\n");
    }
  }
  return 0;
}
void Militant_GpsAnt_forceHome (struct SquareData* field, struct Militant* mem, POS x0,  POS y0)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  POS dx,dy;
  dx = x0 - ant->x;
  dy = y0 - ant->y;
  ant->x += dx;
  ant->y += dy;
  ant->x1 += dx;
  ant->y1 += dy;
}
DefineAnt(Militant, "Militant#ff0000", Militant, struct Militant)
int Militant(struct SquareData* field, struct Militant* mem) {
int result=0;
  switch(STATE(mem)) {
  case Init: result = Militant_Init(field,mem,(struct Militant*)(mem)); break;
  case CW: result = Militant_CW(field,mem,(struct Militant*)(mem)); break;
  case Guard: result = Militant_Guard(field,mem,(struct Militant*)(mem)); break;
  case General: result = Militant_General(field,mem,(struct Militant*)(mem)); break;
  case Create: result = Militant_Create(field,mem,(struct Militant*)(mem)); break;
  case Source: result = Militant_Source(field,mem,(struct Militant*)(mem)); break;
  case Search: result = Militant_Search(field,mem,(struct Militant*)(mem)); break;
  case Patrol: result = Militant_Patrol(field,mem,(struct Militant*)(mem)); break;
  case Return: result = Militant_Return(field,mem,(struct Militant*)(mem)); break;
  case Fetch: result = Militant_Fetch(field,mem,(struct Militant*)(mem)); break;
  case CCW: result = Militant_CCW(field,mem,(struct Militant*)(mem)); break;
  case Recruit: result = Militant_Recruit(field,mem,(struct Militant*)(mem)); break;
  case Deploy: result = Militant_Deploy(field,mem,(struct Militant*)(mem)); break;
  case NONE: if (CLASS(mem)==0) REDISPATCH(Scout,Create);
  }
return result;
}
