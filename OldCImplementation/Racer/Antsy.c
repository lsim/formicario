/* Generated by antcc - The AntC Compiler (http://antc.dotasterisk.net)*/
#include "Myre.h"
#include <stdio.h>
enum { CLASS_Antsy, CLASS_GpsAnt, CLASS_Forager, CLASS_Guard, CLASS_Queen};
enum { NONE, Return, Source, Guard, Init, Search, CW, Deploy, CCW, Recruit, Pause};
#define FETCH(obj,member) (obj)->member
#define REDISPATCH(C,S) return Antsy_REDISPATCH(field,mem,CLASS_##C,S)
struct Antsy {
  /* isa:  */
  /* methods: rnd, kill, has, food */
  u_long random;
char STUFFING[8];
  u_char class;
  u_char state;
};
struct GpsAnt {
  /* isa: Antsy */
  /* methods: atHome, setHome, atTarget, setTarget, gps, Deploy, moveTo, move, home, rnd, kill, has, food */
  u_long random;
  short x;
  short y;
  short x1;
  short y1;
  u_char class;
  u_char state;
};
struct Forager {
  /* isa: GpsAnt */
  /* methods: learn, teach, Search, CW, CCW, search, Return, Source, Init, Search, atHome, setHome, atTarget, setTarget, gps, Deploy, moveTo, move, home, rnd, kill, has, food */
  u_long random;
  short x;
  short y;
  short x1;
  short y1;
  u_char class;
  u_char state;
};
struct Guard {
  /* isa: GpsAnt */
  /* methods: Guard, Init, atHome, setHome, atTarget, setTarget, gps, Deploy, moveTo, move, home, rnd, kill, has, food */
  u_long random;
  short x;
  short y;
  short x1;
  short y1;
  u_char class;
  u_char state;
};
struct Queen {
  /* isa: Antsy */
  /* methods: Init, Pause, Recruit, rnd, kill, has, food */
  u_long random;
  char x;
  char y;
  u_char warriors;
  u_char pause;
  u_char radius;
char STUFFING[3];
  u_char class;
  u_char state;
};

int Antsy(struct SquareData*, struct Antsy*);
int Antsy_Queen_Init (struct SquareData* field, struct Antsy* mem);
u_long Antsy_Antsy_rnd (struct SquareData* field, struct Antsy* mem, int num);
int Antsy_GpsAnt_home (struct SquareData* field, struct Antsy* mem);
int Antsy_Forager_Source (struct SquareData* field, struct Antsy* mem);
int Antsy_GpsAnt_gps (struct SquareData* field, struct Antsy* mem, u_char dir);
u_char Antsy_Antsy_food (struct SquareData* field, struct Antsy* mem);
int Antsy_Forager_learn (struct SquareData* field, struct Antsy* mem);
int Antsy_Forager_Init (struct SquareData* field, struct Antsy* mem);
int Antsy_GpsAnt_Deploy (struct SquareData* field, struct Antsy* mem);
u_char Antsy_Antsy_kill (struct SquareData* field, struct Antsy* mem, u_char dir);
int Antsy_Queen_Recruit (struct SquareData* field, struct Antsy* mem);
int Antsy_Queen_Pause (struct SquareData* field, struct Antsy* mem);
int Antsy_Forager_search (struct SquareData* field, struct Antsy* mem, int cos,  int sin);
int Antsy_Forager_Search (struct SquareData* field, struct Antsy* mem);
int Antsy_Forager_CW (struct SquareData* field, struct Antsy* mem);
void Antsy_GpsAnt_setTarget (struct SquareData* field, struct Antsy* mem, short tx,  short ty);
void Antsy_GpsAnt_setHome (struct SquareData* field, struct Antsy* mem, short x0,  short y0);
int Antsy_Forager_CCW (struct SquareData* field, struct Antsy* mem);
int Antsy_GpsAnt_move (struct SquareData* field, struct Antsy* mem);
int Antsy_Forager_Return (struct SquareData* field, struct Antsy* mem);
int Antsy_Guard_Guard (struct SquareData* field, struct Antsy* mem);
int Antsy_GpsAnt_moveTo (struct SquareData* field, struct Antsy* mem, short tx,  short ty);
int Antsy_Guard_Init (struct SquareData* field, struct Antsy* mem);
int Antsy_GpsAnt_atTarget (struct SquareData* field, struct Antsy* mem);
void Antsy_Forager_teach (struct SquareData* field, struct Antsy* mem);
int Antsy_GpsAnt_atHome (struct SquareData* field, struct Antsy* mem);
int Antsy_Antsy_has (struct SquareData* field, struct Antsy* mem, u_char c);
int Antsy_REDISPATCH(struct SquareData* field, struct Antsy* mem, u_char class, u_char state) {
  mem->class=class; mem->state=state;
  return Antsy(field, mem);
}
void Antsy_SWAP(struct Antsy* obj, struct Antsy* mem)
{
  struct Antsy tmp = *obj; *obj = *mem; *mem = tmp; 
}
int Antsy_Return(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Forager: result = Antsy_Forager_Return(fields,mem); break;
  default: assert(!"no such method (Return) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
u_long Antsy_rnd(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj, int num) {
  u_long result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Antsy: result = Antsy_Antsy_rnd(fields,mem,num); break;
  case CLASS_GpsAnt: result = Antsy_Antsy_rnd(fields,mem,num); break;
  case CLASS_Forager: result = Antsy_Antsy_rnd(fields,mem,num); break;
  case CLASS_Guard: result = Antsy_Antsy_rnd(fields,mem,num); break;
  case CLASS_Queen: result = Antsy_Antsy_rnd(fields,mem,num); break;
  default: assert(!"no such method (rnd) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
void Antsy_teach(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Forager: Antsy_Forager_teach(fields,mem); break;
  default: assert(!"no such method (teach) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
}
u_char Antsy_food(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  u_char result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Antsy: result = Antsy_Antsy_food(fields,mem); break;
  case CLASS_GpsAnt: result = Antsy_Antsy_food(fields,mem); break;
  case CLASS_Forager: result = Antsy_Antsy_food(fields,mem); break;
  case CLASS_Guard: result = Antsy_Antsy_food(fields,mem); break;
  case CLASS_Queen: result = Antsy_Antsy_food(fields,mem); break;
  default: assert(!"no such method (food) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_home(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_GpsAnt: result = Antsy_GpsAnt_home(fields,mem); break;
  case CLASS_Forager: result = Antsy_GpsAnt_home(fields,mem); break;
  case CLASS_Guard: result = Antsy_GpsAnt_home(fields,mem); break;
  default: assert(!"no such method (home) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_gps(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj, u_char dir) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_GpsAnt: result = Antsy_GpsAnt_gps(fields,mem,dir); break;
  case CLASS_Forager: result = Antsy_GpsAnt_gps(fields,mem,dir); break;
  case CLASS_Guard: result = Antsy_GpsAnt_gps(fields,mem,dir); break;
  default: assert(!"no such method (gps) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
u_char Antsy_kill(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj, u_char dir) {
  u_char result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Antsy: result = Antsy_Antsy_kill(fields,mem,dir); break;
  case CLASS_GpsAnt: result = Antsy_Antsy_kill(fields,mem,dir); break;
  case CLASS_Forager: result = Antsy_Antsy_kill(fields,mem,dir); break;
  case CLASS_Guard: result = Antsy_Antsy_kill(fields,mem,dir); break;
  case CLASS_Queen: result = Antsy_Antsy_kill(fields,mem,dir); break;
  default: assert(!"no such method (kill) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_Deploy(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_GpsAnt: result = Antsy_GpsAnt_Deploy(fields,mem); break;
  case CLASS_Forager: result = Antsy_GpsAnt_Deploy(fields,mem); break;
  case CLASS_Guard: result = Antsy_GpsAnt_Deploy(fields,mem); break;
  default: assert(!"no such method (Deploy) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_Source(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Forager: result = Antsy_Forager_Source(fields,mem); break;
  default: assert(!"no such method (Source) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_learn(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Forager: result = Antsy_Forager_learn(fields,mem); break;
  default: assert(!"no such method (learn) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_Guard(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Guard: result = Antsy_Guard_Guard(fields,mem); break;
  default: assert(!"no such method (Guard) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
void Antsy_setTarget(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj, short tx, short ty) {
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_GpsAnt: Antsy_GpsAnt_setTarget(fields,mem,tx,ty); break;
  case CLASS_Forager: Antsy_GpsAnt_setTarget(fields,mem,tx,ty); break;
  case CLASS_Guard: Antsy_GpsAnt_setTarget(fields,mem,tx,ty); break;
  default: assert(!"no such method (setTarget) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
}
int Antsy_Init(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Forager: result = Antsy_Forager_Init(fields,mem); break;
  case CLASS_Guard: result = Antsy_Guard_Init(fields,mem); break;
  case CLASS_Queen: result = Antsy_Queen_Init(fields,mem); break;
  default: assert(!"no such method (Init) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
void Antsy_setHome(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj, short x0, short y0) {
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_GpsAnt: Antsy_GpsAnt_setHome(fields,mem,x0,y0); break;
  case CLASS_Forager: Antsy_GpsAnt_setHome(fields,mem,x0,y0); break;
  case CLASS_Guard: Antsy_GpsAnt_setHome(fields,mem,x0,y0); break;
  default: assert(!"no such method (setHome) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
}
int Antsy_search(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj, int cos, int sin) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Forager: result = Antsy_Forager_search(fields,mem,cos,sin); break;
  default: assert(!"no such method (search) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_Search(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Forager: result = Antsy_Forager_Search(fields,mem); break;
  default: assert(!"no such method (Search) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_move(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_GpsAnt: result = Antsy_GpsAnt_move(fields,mem); break;
  case CLASS_Forager: result = Antsy_GpsAnt_move(fields,mem); break;
  case CLASS_Guard: result = Antsy_GpsAnt_move(fields,mem); break;
  default: assert(!"no such method (move) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_moveTo(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj, short tx, short ty) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_GpsAnt: result = Antsy_GpsAnt_moveTo(fields,mem,tx,ty); break;
  case CLASS_Forager: result = Antsy_GpsAnt_moveTo(fields,mem,tx,ty); break;
  case CLASS_Guard: result = Antsy_GpsAnt_moveTo(fields,mem,tx,ty); break;
  default: assert(!"no such method (moveTo) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_CW(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Forager: result = Antsy_Forager_CW(fields,mem); break;
  default: assert(!"no such method (CW) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_has(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj, u_char c) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Antsy: result = Antsy_Antsy_has(fields,mem,c); break;
  case CLASS_GpsAnt: result = Antsy_Antsy_has(fields,mem,c); break;
  case CLASS_Forager: result = Antsy_Antsy_has(fields,mem,c); break;
  case CLASS_Guard: result = Antsy_Antsy_has(fields,mem,c); break;
  case CLASS_Queen: result = Antsy_Antsy_has(fields,mem,c); break;
  default: assert(!"no such method (has) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_atTarget(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_GpsAnt: result = Antsy_GpsAnt_atTarget(fields,mem); break;
  case CLASS_Forager: result = Antsy_GpsAnt_atTarget(fields,mem); break;
  case CLASS_Guard: result = Antsy_GpsAnt_atTarget(fields,mem); break;
  default: assert(!"no such method (atTarget) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_CCW(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Forager: result = Antsy_Forager_CCW(fields,mem); break;
  default: assert(!"no such method (CCW) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_atHome(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_GpsAnt: result = Antsy_GpsAnt_atHome(fields,mem); break;
  case CLASS_Forager: result = Antsy_GpsAnt_atHome(fields,mem); break;
  case CLASS_Guard: result = Antsy_GpsAnt_atHome(fields,mem); break;
  default: assert(!"no such method (atHome) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_Recruit(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Queen: result = Antsy_Queen_Recruit(fields,mem); break;
  default: assert(!"no such method (Recruit) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_Pause(struct SquareData* fields, struct Antsy* mem, struct Antsy* obj) {
  int result = 0;
  int onSelf = obj == mem;
  if (!onSelf) Antsy_SWAP(obj,mem);
  switch(mem->class) {
  case CLASS_Queen: result = Antsy_Queen_Pause(fields,mem); break;
  default: assert(!"no such method (Pause) for ant ");
  }
  if (!onSelf) Antsy_SWAP(obj,mem);
  return result;
}
int Antsy_Queen_Init (struct SquareData* field, struct Antsy* mem)
{
  struct Queen* ant = (struct Queen*) mem;

  if (ant->radius==0) ant->radius = 64;
  ant->radius += 16;
  
  ant->x = Antsy_rnd(field,mem,(struct Antsy*)(ant), ant->radius);
  ant->y = ant->radius-ant->x;
  if (Antsy_rnd(field,mem,(struct Antsy*)(ant), 2)) ant->x = -ant->x;
  if (Antsy_rnd(field,mem,(struct Antsy*)(ant), 2)) ant->y = -ant->y;
  
  ant->warriors = 32;
  ant->pause = 255;
  
  REDISPATCH(Queen,Pause);
}
u_long Antsy_Antsy_rnd (struct SquareData* field, struct Antsy* mem, int num)
{
  struct Antsy* ant = (struct Antsy*) mem;

  // Randomizer stolen from some other ant
  u_short* rvals = (u_short*) ant;
  u_long a=rvals[0], b=rvals[1];
  a=(a*133)%65521;
  b=b*135+7;
  b=(b>>1)+((b&1)<<15);
  rvals[1]=a; rvals[0]=b;
  return (((a^b)&0xffff)*num)>>16;
}
int Antsy_GpsAnt_home (struct SquareData* field, struct Antsy* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  return Antsy_moveTo(field,mem,(struct Antsy*)(ant), 0,0);
}
int Antsy_Forager_Source (struct SquareData* field, struct Antsy* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  int i;
  
  // food in neighboring field?
  for (i=1; i<5; ++i) {
    if (field[i].NumFood > field[i].NumAnts) {
      ant->state = Search;
      return Antsy_gps(field,mem,(struct Antsy*)(ant), Antsy_kill(field,mem,(struct Antsy*)(ant), i));
    }
  }
  
  if (Antsy_atTarget(field,mem,(struct Antsy*)(ant))){
    // source reached. if there's food left, bring it home; otherwise init ant->random search
    if (field[0].NumFood && !Antsy_atHome(field,mem,(struct Antsy*)(ant))) REDISPATCH(Forager,Return);
    else REDISPATCH(Forager,Init);
  }
  
  // move on.
  Antsy_teach(field,mem,(struct Antsy*)(ant));
  return Antsy_move(field,mem,(struct Antsy*)(ant));
}
int Antsy_GpsAnt_gps (struct SquareData* field, struct Antsy* mem, u_char dir)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;
 
  short DX[5] = {0, 1,  0, -1,  0};
  short DY[5] = {0, 0, -1,  0,  1};
  
  if (field[dir].NumAnts == MaxSquareAnts && !field[dir].Team) return 0;
  
  ant->x+=DX[dir];
  ant->y+=DY[dir];
  return dir;
}
u_char Antsy_Antsy_food (struct SquareData* field, struct Antsy* mem)
{
  struct Antsy* ant = (struct Antsy*) mem;

  int i;
  for (i=1; i<5; ++i) 
    if (field[i].NumAnts < field[i].NumFood) return i;
  return 0;
}
int Antsy_Forager_learn (struct SquareData* field, struct Antsy* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  int i = 0;
  if(field[0].NumAnts==1) return 0;
  for(i=1; i<field[0].NumAnts; ++i) {
    //printf("learning from ant %d @ %d,%d", i,ant->x,ant->y);
    if (ant[i].class == ant->class && ant[i].state != Deploy) {
      Antsy_setHome(field,mem,(struct Antsy*)(ant), ant[i].x, ant[i].y);
      Antsy_setHome(field,mem,(struct Antsy*)(&(ant[i])), ant->x,ant->y);
      if (ant[i].state == Return || ant[i].state == Source) {
	ant->x1 = ant[i].x1;
	ant->y1 = ant[i].y1;
	if (Antsy_atTarget(field,mem,(struct Antsy*)(ant))) return 0;
	//printf(" about food @ %d,%d\n",xm,ym);
	return (ant->x1!=0 && ant->y1!=0);
      }
      //printf("\n");
    }
  }
  return 0;
}
int Antsy_Forager_Init (struct SquareData* field, struct Antsy* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  short dx,dy;
  // become queen?
  if (!Antsy_has(field,mem,(struct Antsy*)(ant), CLASS_Queen) && field->Base) REDISPATCH(Queen,Init);
  
  ant->x1+=0;
  ant->y1+=0;
  
  dx = Antsy_rnd(field,mem,(struct Antsy*)(ant), 32);
  dy = Antsy_rnd(field,mem,(struct Antsy*)(ant), 32)-dx;
  if(Antsy_rnd(field,mem,(struct Antsy*)(ant), 2)) dx = -dx;
  if(Antsy_rnd(field,mem,(struct Antsy*)(ant), 2)) dy = -dy;
  
  ant->x1 += dx;// - ant->x/4;
  ant->y1 += dy;// - ant->y/4;
  REDISPATCH(Forager,Search);
}
int Antsy_GpsAnt_Deploy (struct SquareData* field, struct Antsy* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  if(ant->x==ant->x1 && ant->y==ant->y1) ant->state = Init;
  return Antsy_move(field,mem,(struct Antsy*)(ant));
}
u_char Antsy_Antsy_kill (struct SquareData* field, struct Antsy* mem, u_char dir)
{
  struct Antsy* ant = (struct Antsy*) mem;

  int i=0;
  for (i=1; i<5; ++i)
    if (field[i].Team) return i;
  return dir;
}
int Antsy_Queen_Recruit (struct SquareData* field, struct Antsy* mem)
{
  struct Queen* ant = (struct Queen*) mem;
 
  int i;
  if(ant->warriors==0) REDISPATCH(Queen,Init);
  
  for (i=1; i<field->NumAnts && ant->warriors>0; ++i) {
    if (ant[i].state == NONE) {
      struct Forager* it = (struct Forager*) &(ant[i]);
      it->state = Source;
      it->class = CLASS_Forager;
      it->x1 = ant->x;
      it->y1 = ant->y;
      --ant->warriors;
      break;
    }
  }
  
  return 0;
}
int Antsy_Queen_Pause (struct SquareData* field, struct Antsy* mem)
{
  struct Queen* ant = (struct Queen*) mem;

  if (!ant->pause) REDISPATCH(Queen,Recruit);
  --ant->pause;
  return 0;
}
int Antsy_Forager_search (struct SquareData* field, struct Antsy* mem, int cos,  int sin)
{
  struct Forager* ant = (struct Forager*) mem;

#define skrue 222

  int i=0;
  int knowledge = Antsy_learn(field,mem,(struct Antsy*)(ant));
  
  if (abs(ant->x)>1 || abs(ant->y)>1) {
    // food here?
    if (field->NumFood) {
      // remember where the food is
      ant->x1 = ant->x;
      ant->y1 = ant->y;
      // and go home
      REDISPATCH(Forager,Return);
    }
    
    // food in neighboring field?
    for (i=1; i<5; ++i) {
      if (field[i].NumFood > field[i].NumAnts) {
	return Antsy_gps(field,mem,(struct Antsy*)(ant), Antsy_kill(field,mem,(struct Antsy*)(ant), i));
      }
    }
  }
  
  // if target reached, go somewhere else
  if (Antsy_atTarget(field,mem,(struct Antsy*)(ant))) { 
    Antsy_setTarget(field,mem,(struct Antsy*)(ant),  ((ant->x1*cos-ant->y1*sin)/skrue)+Antsy_rnd(field,mem,(struct Antsy*)(ant), 15)-7, ((ant->y1*cos+ant->x1*sin)/skrue)+Antsy_rnd(field,mem,(struct Antsy*)(ant), 15)-7 );
    //REDISPATCH(Forager,Init);
    //printf("target reached\n");
    //ant->x1 += Antsy_rnd(field,mem,(struct Antsy*)(ant), 32) - 16;
    //ant->y1 += Antsy_rnd(field,mem,(struct Antsy*)(ant), 32) - 16;
  }
  else {
    if(knowledge) REDISPATCH(Forager,Source);
  }
  return Antsy_move(field,mem,(struct Antsy*)(ant));
}
int Antsy_Forager_Search (struct SquareData* field, struct Antsy* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  int i=0;
  int knowledge = Antsy_learn(field,mem,(struct Antsy*)(ant));
  
  if (abs(ant->x)>1 && abs(ant->y)>1) {
    // food here?
    if (field->NumFood) {
      // remember where the food is
      ant->x1 = ant->x;
      ant->y1 = ant->y;
      // and go home
      REDISPATCH(Forager,Return);
    }
    
    // food in neighboring field?
    for (i=1; i<5; ++i) {
      if (field[i].NumFood > field[i].NumAnts) {
	return Antsy_gps(field,mem,(struct Antsy*)(ant), Antsy_kill(field,mem,(struct Antsy*)(ant), i));
      }
    }
  }
  
  // if target reached, go somewhere else
  if (ant->x==ant->x1 && ant->y==ant->y1){
    //printf("target reached\n");
    ant->x1 += Antsy_rnd(field,mem,(struct Antsy*)(ant), 32) - 16;
    ant->y1 += Antsy_rnd(field,mem,(struct Antsy*)(ant), 32) - 16;
  }
  else {
    if(knowledge) REDISPATCH(Forager,Source);
  }
  return Antsy_move(field,mem,(struct Antsy*)(ant));
}
int Antsy_Forager_CW (struct SquareData* field, struct Antsy* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  return Antsy_search(field,mem,(struct Antsy*)(ant), 222, -128);
}
void Antsy_GpsAnt_setTarget (struct SquareData* field, struct Antsy* mem, short tx,  short ty)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  ant->x1 = tx; 
  ant->y1 = ty;
}
void Antsy_GpsAnt_setHome (struct SquareData* field, struct Antsy* mem, short x0,  short y0)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  short dx,dy;
  if(abs(x0)+abs(y0) < abs(ant->x)+abs(ant->y)) {
    dx = x0 - ant->x;
    dy = y0 - ant->y;
    ant->x += dx;
    ant->y += dy;
    ant->x1 += dx;
    ant->y1 += dy;
  }
}
int Antsy_Forager_CCW (struct SquareData* field, struct Antsy* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  return Antsy_search(field,mem,(struct Antsy*)(ant), 222, 128);
}
int Antsy_GpsAnt_move (struct SquareData* field, struct Antsy* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  return Antsy_moveTo(field,mem,(struct Antsy*)(ant), ant->x1,ant->y1);
}
int Antsy_Forager_Return (struct SquareData* field, struct Antsy* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  Antsy_teach(field,mem,(struct Antsy*)(ant));
  
  if (Antsy_atHome(field,mem,(struct Antsy*)(ant))) {
    // build a new base if possible
    if (field->NumFood >= NewBaseFood) return 16;
  }
  else {
    // any food to move? Then move it towards the base
    if (field->NumFood) return 8 + Antsy_moveTo(field,mem,(struct Antsy*)(ant), 0,0);
  }
  
  // we've delivered the food at the base or lost the food. return to food source.
  REDISPATCH(Forager,Source);
}
int Antsy_Guard_Guard (struct SquareData* field, struct Antsy* mem)
{
  struct Guard* ant = (struct Guard*) mem;

  int k = Antsy_kill(field,mem,(struct Antsy*)(ant), 0);
  if (k) return Antsy_gps(field,mem,(struct Antsy*)(ant), k);
  if (!Antsy_rnd(field,mem,(struct Antsy*)(ant), 400)) REDISPATCH(Forager,Init);
  return 0;
}
int Antsy_GpsAnt_moveTo (struct SquareData* field, struct Antsy* mem, short tx,  short ty)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  enum {center=0, east=1, south=2, west=3, north=4};
  short dx = tx-ant->x;
  short dy = ty-ant->y;
  u_char dir = 0;
  int kill = Antsy_kill(field,mem,(struct Antsy*)(ant), 0);
  if (kill) REDISPATCH(Guard,Init);
  
  if (dx && dy) Antsy_rnd(field,mem,(struct Antsy*)(ant), abs(dx)+abs(dy)) >= abs(dx) ? (dx=0) : (dy=0);
  if (dx && !dy) dir = dx<0 ? west : east;
  if (dy && !dx) dir = dy<0 ? south : north;
  return Antsy_gps(field,mem,(struct Antsy*)(ant), dir);
}
int Antsy_Guard_Init (struct SquareData* field, struct Antsy* mem)
{
  struct Guard* ant = (struct Guard*) mem;

  REDISPATCH(Guard,Guard);
}
int Antsy_GpsAnt_atTarget (struct SquareData* field, struct Antsy* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  return ant->x==ant->x1 && ant->y==ant->y1;
}
void Antsy_Forager_teach (struct SquareData* field, struct Antsy* mem)
{
  struct Forager* ant = (struct Forager*) mem;

  int i;
  if(field[0].NumAnts==1) return;
  for(i=1; i<field[0].NumAnts; ++i) {
    //printf("teaching ant %d @ %d,%d", i,ant->x,ant->y);
    if (ant[i].class == ant->class && ant[i].state != Deploy) { // && ant[i].x==ant->x && ant[i].y==ant->y)
      Antsy_setHome(field,mem,(struct Antsy*)(ant), ant[i].x, ant[i].y);
      Antsy_setHome(field,mem,(struct Antsy*)(&(ant[i])), ant->x,ant->y);
      if (ant[i].state == Search || ant[i].state == Init) {
	ant[i].x1 = ant->x1;
	ant[i].y1 = ant->y1;
	ant[i].state = Source;
	//printf(" about food @ %d,%d\n",xm,ym);
      }
      //printf("\n");
    }
  }
}
int Antsy_GpsAnt_atHome (struct SquareData* field, struct Antsy* mem)
{
  struct GpsAnt* ant = (struct GpsAnt*) mem;

  return ant->x==0 && ant->y==0;
}
int Antsy_Antsy_has (struct SquareData* field, struct Antsy* mem, u_char c)
{
  struct Antsy* ant = (struct Antsy*) mem;

  int i;
  for (i=1; i<field->NumAnts; ++i)
    if (ant[i].class == c) return i;
  return 0;
}
DefineAnt(Antsy, "Antsy", Antsy, struct Antsy)
int Antsy(struct SquareData* field, struct Antsy* mem) {
  switch(mem->state) {
  case Return: return Antsy_Return(field,mem,(struct Antsy*)(mem));
  case Source: return Antsy_Source(field,mem,(struct Antsy*)(mem));
  case Guard: return Antsy_Guard(field,mem,(struct Antsy*)(mem));
  case Init: return Antsy_Init(field,mem,(struct Antsy*)(mem));
  case Search: return Antsy_Search(field,mem,(struct Antsy*)(mem));
  case CW: return Antsy_CW(field,mem,(struct Antsy*)(mem));
  case Deploy: return Antsy_Deploy(field,mem,(struct Antsy*)(mem));
  case CCW: return Antsy_CCW(field,mem,(struct Antsy*)(mem));
  case Recruit: return Antsy_Recruit(field,mem,(struct Antsy*)(mem));
  case Pause: return Antsy_Pause(field,mem,(struct Antsy*)(mem));
  case NONE: if (mem->class==CLASS_Antsy) REDISPATCH(Forager,Init);
  }
return 0;
}
